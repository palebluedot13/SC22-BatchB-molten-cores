{"backend_state":"running","connection_file":"/projects/afffd160-11c4-4b0e-8185-cf29c729cf98/.local/share/jupyter/runtime/kernel-d8732196-b137-4628-9e06-22cfe631a670.json","kernel":"ds_env","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.13"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":26,"id":"72739a","input":"labels = ['Electronic', 'Anime', 'Jazz', 'Alternative', 'Country', 'Rap', 'Blues', 'Rock', 'Classical', 'Hip-Hop']\nsns.heatmap(confusion_matrix(y_test.values.argmax(axis=1), y_pred.argmax(axis=1)), annot=True, fmt='g', xticklabels=labels, yticklabels=labels)","output":{"0":{"data":{"text/plain":"<AxesSubplot:>"},"exec_count":26,"output_type":"execute_result"},"1":{"data":{"image/png":"510e0111c0defad99c6229623dabf6bcaaba2f21","text/plain":"<Figure size 432x288 with 2 Axes>"},"exec_count":26,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":3,"type":"cell"}
{"cell_type":"code","exec_count":42,"id":"80b712","input":"#imports\nimport pandas as pd\nimport plotly.express as px\nimport numpy as np\nimport seaborn as sns\nimport plotly.io as pio\nimport numpy as np\nimport xgboost as xgb\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\n\nfrom xgboost import XGBClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import make_scorer, f1_score, accuracy_score, confusion_matrix, classification_report,roc_curve, roc_auc_score\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import preprocessing\nfrom sklearn.model_selection import GridSearchCV\n\n#importing datasets\nmusic_data = pd.read_csv(\"music_genre.csv\")\ndf = music_data.copy(deep=True)\n\n#makes theme dark for all ploty visuals\npio.templates.default = \"plotly_dark\"\n\n\n\n\n\n#dropping irrelevent columns\nbadInfo = [\"instance_id\",\"obtained_date\",\"artist_name\",\"track_name\"]\ndf.drop(columns=badInfo,axis=1,inplace=True)\n\n#dropping null rows\ndf.dropna(inplace=True)\ndf.reset_index(drop=True, inplace=True) #Very good practice to reset how your rows are counted when you drop rows.\n\n#fixing tempo\ndf[\"tempo\"]=df[\"tempo\"].replace(\"?\",np.nan)\ndf[\"tempo\"] = df[\"tempo\"].astype(\"float\")\ndf[\"tempo\"]=df.groupby(\"music_genre\")[\"tempo\"].transform(lambda x: x.fillna(x.mean(skipna=True)))\n\n#fixing duration\ndf[\"duration_ms\"]=df[\"duration_ms\"].replace(-1.0,np.nan)\ndf[\"duration_ms\"]=df.groupby(\"music_genre\")[\"duration_ms\"].transform(lambda x: x.fillna(x.mean(skipna=True)))\ndf['duration_ms'] = np.around(df['duration_ms'],2)","pos":0,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":43,"id":"d121bd","input":"'''\n#creating dummy variables for categorical variables\ndummies = pd.get_dummies(df[\"key\"])\ndf[\"A\"] = dummies[\"A\"]\ndf[\"B\"] = dummies[\"B\"]\ndf[\"C\"] = dummies[\"C\"]\ndf[\"D\"] = dummies[\"D\"]\ndf[\"E\"] = dummies[\"E\"]\ndf[\"F\"] = dummies[\"F\"]\ndf[\"G\"] = dummies[\"G\"]\ndf[\"A#\"] = dummies[\"A#\"]\ndf[\"C#\"] = dummies[\"C#\"]\ndf[\"D#\"] = dummies[\"D#\"]\ndf[\"F#\"] = dummies[\"F#\"]\ndf[\"G#\"] = dummies[\"G#\"]\ndf.drop(\"key\", axis = 1, inplace = True)\n\ndummies = pd.get_dummies(df[\"mode\"])\ndf[\"Major\"] = dummies[\"Major\"]\ndf[\"Minor\"] = dummies[\"Minor\"]\ndf.drop(\"mode\", axis = 1, inplace = True)\n\ndummies = pd.get_dummies(df[\"music_genre\"])\ndf[\"Electronic\"] = dummies[\"Electronic\"]\ndf[\"Anime\"] = dummies[\"Anime\"]\ndf[\"Jazz\"] = dummies[\"Jazz\"]\ndf[\"Alternative\"] = dummies[\"Alternative\"]\ndf[\"Country\"] = dummies[\"Country\"]\ndf[\"Rap\"] = dummies[\"Rap\"]\ndf[\"Blues\"] = dummies[\"Blues\"]\ndf[\"Rock\"] = dummies[\"Rock\"]\ndf[\"Classical\"] = dummies[\"Classical\"]\ndf[\"Hip-Hop\"] = dummies[\"Hip-Hop\"]\ndf.drop(\"music_genre\", axis = 1, inplace = True)\ndf.head()\n'''\n\n\n#This function replaces labels, such as Jazz, Rock, Rap, etc. with numbers. Each label now carries it's own number\n\ndef stringToInt(dataFrame,col):\n    test = {}\n    for i in dict(enumerate(dataFrame[col].unique())).items():#is a dictionary of the keys and corespodening number\n        #makes it so the keys and values of the dictionary switch\n        test[i[1]]=i[0]\n    print(test,'\\n')\n    return dataFrame[col].map(test)\n\ndef getScore(y_test,y_hat):\n    labels = ['Electronic', 'Anime', 'Jazz', 'Alternative', 'Country', 'Rap', 'Blues', 'Rock', 'Classical', 'Hip-Hop']\n    print((np.sum((y_test - y_hat)**2))/len(y_test) )#mean squared error\n    print(classification_report(y_test, y_hat,target_names=[i+\":\" for i in labels]))#getting dataframe\ndf = pd.read_csv(\"music_genre.csv\")\n\n#dropping columns\nbadInfo = [\"instance_id\",\"obtained_date\",\"artist_name\",\"track_name\"]\ndf.drop(columns=badInfo,axis=1,inplace=True)\n\n#dropping null rows\ndf.dropna(inplace=True)\ndf.reset_index(drop=True, inplace=True) #Very good practice to reset how your rows are counted when you drop rows.\n\n#fixing the problem with 'tempo' column\ndf[\"tempo\"]=df[\"tempo\"].replace(\"?\",np.nan)\ndf[\"tempo\"] = df[\"tempo\"].astype(\"float\")\ndf[\"tempo\"]=df.groupby(\"music_genre\")[\"tempo\"].transform(lambda x: x.fillna(x.mean(skipna=True)))\ndf['tempo'] = np.around(df['tempo'],2)\n\n#fixing the problem with 'duration' column\ndf[\"duration_ms\"]=df[\"duration_ms\"].replace(-1.0,np.nan)\ndf[\"duration_ms\"]=df.groupby(\"music_genre\")[\"duration_ms\"].transform(lambda x: x.fillna(x.mean(skipna=True)))\ndf['duration_ms'] = np.around(df['duration_ms'],2)\n\n#changing the values from string to int\ndf['key'] = stringToInt(df,'key')\ndf['mode'] = stringToInt(df,'mode')\ndf['music_genre_name'] = df['music_genre']\ndf['music_genre'] = stringToInt(df,'music_genre')\n\npio.templates.default = \"plotly_dark\"\n\n#dfxg = copy.deepcopy(df)\n\n#Setting X to be all the input columns \nX = df.loc[:,df.columns[:-2]]\n\n\n#Setting y to be the desired column\ny= df['music_genre']#what we want\n\n#Splitting test and train ratio\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)\n\n#Scaling X variables\nsc = preprocessing.StandardScaler()\nX_train = sc.fit_transform(X_train)\nX_test = sc.transform (X_test)\n\n#for heat map\nlabels = ['Electronic', 'Anime', 'Jazz', 'Alternative', 'Country', 'Rap', 'Blues', 'Rock', 'Classical', 'Hip-Hop']","output":{"0":{"name":"stdout","output_type":"stream","text":"{'A#': 0, 'D': 1, 'G#': 2, 'C#': 3, 'F#': 4, 'B': 5, 'G': 6, 'F': 7, 'A': 8, 'C': 9, 'E': 10, 'D#': 11} \n\n{'Minor': 0, 'Major': 1} \n\n{'Electronic': 0, 'Anime': 1, 'Jazz': 2, 'Alternative': 3, 'Country': 4, 'Rap': 5, 'Blues': 6, 'Rock': 7, 'Classical': 8, 'Hip-Hop': 9} \n\n"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":44,"id":"e9b000","input":"# genre_list = ['Electronic', 'Anime', 'Jazz', 'Alternative', 'Country', 'Rap', 'Blues', 'Rock', 'Classical', 'Hip-Hop']\n# # target = pd.get_dummies(dummies)\n# # input_columns = df.iloc[:,:-10]\n# # x_train, x_test, y_train, y_test = train_test_split(input_columns, target, train_size=0.8)\n# # scaler = preprocessing.StandardScaler().fit(x_train)\n# # x_train_scaled = scaler.transform(x_train)\n# # x_test_scaled = scaler.transform(x_test)\n\n# #use_label_encoder=False, eval_metric='mlogloss'\n# #booster='gbtree', max_depth=4, subsample=.5, gamma= 4, colsample_bytree=.5\n# model = XGBClassifier()\n# model_gs = GridSearchCV(model,param_grid=PARAMETERS,cv=3,scoring=\"accuracy\")\n# model_gs.fit(X_train,y_train,early_stopping_rounds=10, eval_metric=\"error\",eval_set=eval_set,verbose=0)\n# print(model_gs.best_params_)\n# #model.fit(x_train_scaled, y_train)\n\n\n\n\nestimator = XGBClassifier(\n    objective= 'binary:logistic',\n    nthread=4,\n    seed=42\n)\nparameters = {\n    'max_depth': range (2, 10, 1),\n    'n_estimators': range(60, 220, 40),\n    'learning_rate': [0.1, 0.01, 0.05]\n}\ngrid_search = GridSearchCV(\n    estimator=estimator,\n    param_grid=parameters,\n    scoring = 'roc_auc',\n    n_jobs = 10,\n    cv = 2,\n    verbose=True\n)\ngrid_search.fit(X_train, y_train)\n\ngrid_search.best_estimator_\n\n'''\nmodel = xgb.XGBClassifier(use_label_encoder=False, eval_metric='mlogloss')\nmodel.fit(X_train, y_train).predict(X_test)\n\ny_pred = model.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprint(\"Overall Accuracy: \", accuracy)\n\ntotal_squared_error = (np.sum((y_test - y_pred)**2))\nmean_squared_error = total_squared_error/len(y_test)\nprint(mean_squared_error)\n\n#confusion matrix\nlabels = ['Electronic', 'Anime', 'Jazz', 'Alternative', 'Country', 'Rap', 'Blues', 'Rock', 'Classical', 'Hip-Hop']\n# sns.heatmap(confusion_matrix(y_test.values.argmax(axis=1), y_pred.argmax(axis=1)), annot=True, fmt='g', xticklabels=labels, yticklabels=labels)\nsns.heatmap(confusion_matrix(y_test, y_pred), annot=True, fmt='g', xticklabels=labels, yticklabels=labels)\ngetScore(y_test,y_pred)\n'''","output":{"0":{"name":"stdout","output_type":"stream","text":"Fitting 2 folds for each of 96 candidates, totalling 192 fits\n"}},"pos":2,"type":"cell"}
{"exec_count":2,"id":"ebdcd0","input":"print(grid_search.best_estimator_)","kernel":"ds_env","output":{"0":{"ename":"NameError","evalue":"name 'grid_search' is not defined","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)","Input \u001b[0;32mIn [2]\u001b[0m, in \u001b[0;36m<cell line: 1>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[43mgrid_search\u001b[49m\u001b[38;5;241m.\u001b[39mbest_estimator)\n","\u001b[0;31mNameError\u001b[0m: name 'grid_search' is not defined"]}},"pos":2.5,"state":"done","type":"cell"}
{"id":0,"time":1657294272079,"type":"user"}
{"last_load":1657299260490,"type":"file"}